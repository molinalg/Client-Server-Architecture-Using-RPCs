/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>

#include "ejev3.h"

const char* filename = "./tuples/tupla_";     // Ruta relativa del fichero de tupla (sin num. clave)
const char* ext = ".dat";                     // Extension del fichero de tupla
const char* dirname =  "tuples";              // Nombre del directorio

bool_t
init_tuples_1_svc(int *result, struct svc_req *rqstp)
{
	bool_t retval;

	DIR* tpl_dir;

    struct dirent *tpl_entry;
    char entry_path[512];

    if ((tpl_dir = opendir(dirname)) == NULL){
        perror("[SERVIDOR][ERROR] El directorio no pudo ser abierto\n");
        *result = -1;
		retval = TRUE;
		return retval;
    }

    // Elimina los ficheros con extesion .dat
    while ((tpl_entry = readdir(tpl_dir)) != NULL) {
            if (strstr(tpl_entry->d_name, ".dat") != NULL){
                snprintf(entry_path, 512, "%s/%s", dirname, tpl_entry->d_name);
                remove(entry_path);
            }
    }

    closedir(tpl_dir);

    if (rmdir(dirname) == -1) {
        perror("[SERVIDOR][ERROR] El fichero no pudo ser eliminado\n");
		*result = -1;
		retval = TRUE;
		return retval;
    }

    if (mkdir(dirname, 0755) == -1) {
        perror("[SERVIDOR][ERROR] El directorio no pudo ser creado\n");
		*result = -1;
		retval = TRUE;
        return retval;
    }

	*result = 0;
	retval = TRUE;

	return retval;
}

bool_t
set_value_tuples_1_svc(int key, char *value1, int value2, double value3, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	// Obtiene nombre completo del fichero
    char tuple_file [1024];
    sprintf(tuple_file, "%s%d%s", filename, key, ext);

    if (!access(tuple_file, F_OK)){
        perror("[SERVIDOR][ERROR] Fichero ya existente\n");
		*result = -1;
		retval = TRUE;
        return retval;
    }

    FILE* tpl_fp;

    if ((tpl_fp = fopen(tuple_file, "w")) == NULL){
        perror("[SERVIDOR][ERROR] El fichero para la tupla no pudo ser creado\n");
		*result = -1;
		retval = TRUE;
        return retval;
    }

    t_tuple tupla;
    tupla.key = key;
    tupla.value1 = malloc(sizeof(char) * (strlen(value1) + 1));
    strcpy(tupla.value1, value1);
    tupla.value2 = value2;
    tupla.value3 = value3; 

    if (fwrite(&tupla, sizeof(t_tuple), 1, tpl_fp) == 0){
        perror("[SERVIDOR][ERROR] No se pudo escribir en el fichero\n");
        fclose(tpl_fp);
		*result = -1;
		retval = TRUE;
        return retval;
    }

    fclose(tpl_fp);
	*result = 0;
	retval = TRUE;
	return retval;
}

bool_t
get_value_tuples_1_svc(int key, t_service *result,  struct svc_req *rqstp)
{
	bool_t retval;
	t_service respuesta;
	t_tuple tupla;

	// Obtiene nombre completo del fichero
    char tuple_file [1024];
    sprintf(tuple_file, "%s%d%s", filename, key, ext);

    if (access(tuple_file, F_OK)){
        perror("[SERVIDOR][ERROR] Fichero no existe\n");
		respuesta.status = -1;
		*result = respuesta;
		retval = TRUE;
        return retval;
    }
    FILE* tpl_fp;

    if ((tpl_fp = fopen(tuple_file, "r")) == NULL){
        perror("[SERVIDOR][ERROR] El fichero para la tupla no pudo ser abierto\n");
		respuesta.status = -1;
		*result = respuesta;
		retval = TRUE;
        return retval;
    }
    if (fread(&tupla, sizeof(t_tuple), 1, tpl_fp) == 0){
        perror("[SERVIDOR][ERROR] Fichero no pudo leerse\n");
        fclose(tpl_fp);
		respuesta.status = -1;
		*result = respuesta;
		retval = TRUE;
        return retval;
    }
    fclose(tpl_fp);
	respuesta.status = 0;
    respuesta.content = tupla;

	*result = respuesta;
	retval = TRUE;
	return retval;
}

bool_t
modify_value_tuples_1_svc(int key, char *value1, int value2, double value3, int *result,  struct svc_req *rqstp)
{
	bool_t retval;

	// Obtiene nombre completo del fichero
    char tuple_file [1024];
    sprintf(tuple_file, "%s%d%s", filename, key, ext);
    

    if (access(tuple_file, F_OK)){
        perror("[SERVIDOR][ERROR] Fichero no existe\n");
		*result = -1;
		retval = TRUE;
        return retval;
    }

    if (remove(tuple_file) == -1){
        perror("[SERVIDOR][ERROR] El directorio no pudo ser eliminado\n");
		*result = -1;
		retval = TRUE;
        return retval;
    }

    FILE* tpl_fp;

    if ((tpl_fp = fopen(tuple_file, "w")) == NULL){
        perror("[SERVIDOR][ERROR] El fichero para la tupla no pudo ser creado\n");
		*result = -1;
		retval = TRUE;
        return retval;
    }

    t_tuple tupla;
    tupla.key = key;
    strcpy(tupla.value1, value1);
    tupla.value2 = value2;
    tupla.value3 = value3;

    if (fwrite(&tupla, sizeof(t_tuple), 1, tpl_fp) == 0){
        perror("[SERVIDOR][ERROR] No se pudo escribir en el fichero\n");
        fclose(tpl_fp);
		*result = -1;
		retval = TRUE;
        return retval;
    }
    
    fclose(tpl_fp);

	*result = 0;
	retval = TRUE;

	return retval;
}

bool_t
delete_key_tuples_1_svc(int key, int *result,  struct svc_req *rqstp)
{
	bool_t retval;

	// Obtiene nombre completo del fichero
    char tuple_file [1024];
    sprintf(tuple_file, "%s%d%s", filename, key, ext);

    if (access(tuple_file, F_OK)){
        perror("[SERVIDOR][ERROR] Fichero no existe\n");
		*result = -1;
		retval = TRUE;
        return retval;
    }
    
    if (remove(tuple_file) == -1){
        perror("[SERVIDOR][ERROR] El directorio no pudo ser eliminado\n");
		*result = -1;
		retval = TRUE;
        return retval;
    }

	*result = 0;
	retval = TRUE;

	return retval;
}

bool_t
exist_tuples_1_svc(int key, int *result,  struct svc_req *rqstp)
{
	bool_t retval;

	// Obtiene nombre completo del fichero
    char tuple_file [1024];
    sprintf(tuple_file, "%s%d%s", filename, key, ext);
    
    if (!access(tuple_file, F_OK)){
		*result = 1;
		retval = TRUE;
        return retval;
	}

	*result = 0;
	retval = TRUE;

	return retval;
}

bool_t
copy_key_tuples_1_svc(int key1, int key2, int *result,  struct svc_req *rqstp)
{
	bool_t retval;

	// Obtiene nombre completo del fichero original (key 1)
    char original_tpl_file [1024], copy_tpl_file [1024];
    sprintf(original_tpl_file, "%s%d%s", filename, key1, ext);

    if (access(original_tpl_file, F_OK)){
        perror("[SERVIDOR][ERROR] Fichero no existe\n");
		*result = -1;
		retval = TRUE;
        return retval;
    }

    FILE* original_tpl_fp;
    FILE* copy_tpl_fp;

    t_tuple tupla;

    if ((original_tpl_fp = fopen(original_tpl_file, "r")) == NULL){
        perror("[SERVIDOR][ERROR] El fichero para la tupla no pudo ser creado\n");
		*result = -1;
		retval = TRUE;
        return retval;
    }

    if (fread(&tupla, sizeof(t_tuple), 1, original_tpl_fp) == 0){
        perror("[SERVIDOR][ERROR] Fichero no pudo leerse\n");
        fclose(original_tpl_fp);
		*result = -1;
		retval = TRUE;
        return retval;
    }

    fclose(original_tpl_fp);

    tupla.key = key2;

    // Obtiene nombre completo del fichero copia (key 2)
    sprintf(copy_tpl_file, "%s%d%s", filename, key2, ext);

    if ((copy_tpl_fp = fopen(copy_tpl_file, "w")) == NULL){
        perror("[SERVIDOR][ERROR] El fichero para la tupla no pudo ser creado/abierto\n");
		*result = -1;
		retval = TRUE;
        return retval;
    }

    if (fwrite(&tupla, sizeof(t_tuple), 1, copy_tpl_fp) == 0){
        perror("[SERVIDOR][ERROR] No se pudo escribir en el fichero\n");
        fclose(copy_tpl_fp);
		*result = -1;
		retval = TRUE;
        return retval;
    }
    
    fclose(copy_tpl_fp);

	*result = 0;
	retval = TRUE;

	return retval;
}

int
tuplas_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
